{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///home/deepakps/Documents/GitHub/AI_fitness_coach/backend/db.ts"],"sourcesContent":["import { Pool } from \"pg\"\nimport type { PlanContent } from \"@/lib/plan-types\"\nimport type { UserData } from \"@/components/app-wrapper\"\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n  ssl: { rejectUnauthorized: false },\n})\n\nconst initPromise = pool.query(`\n  create table if not exists user_accounts (\n    email            text primary key,\n    password_hash    text not null,\n    name             text,\n    age              integer,\n    gender           text,\n    height           numeric(6,2),\n    weight           numeric(6,2),\n    goal             text,\n    level            text,\n    location         text,\n    dietary_prefs    text[],\n    medical_history  text,\n    stress_level     text,\n    created_at       timestamptz default now(),\n    updated_at       timestamptz default now()\n  );\n\n  create table if not exists user_plans (\n    email      text primary key references user_accounts(email) on delete cascade,\n    user_data  jsonb,\n    plan       jsonb not null,\n    updated_at timestamptz default now()\n  );\n`)\n\nconst TABLE = \"user_plans\"\nconst USER_TABLE = \"user_accounts\"\n\nexport interface PlanRecord {\n  email: string\n  user_data: Partial<UserData>\n  plan: PlanContent\n  updated_at?: string\n}\n\nexport interface UserAccount extends Partial<UserData> {\n  email: string\n  password_hash: string\n  created_at?: string\n  updated_at?: string\n}\n\nfunction normalizeProfile(profile: Partial<UserData>) {\n  return {\n    name: profile.name ?? null,\n    age: profile.age ?? null,\n    gender: profile.gender ?? null,\n    height: profile.height ?? null,\n    weight: profile.weight ?? null,\n    goal: profile.goal ?? null,\n    level: profile.level ?? null,\n    location: profile.location ?? null,\n    dietaryPrefs: profile.dietaryPrefs ?? null,\n    medicalHistory: profile.medicalHistory ?? null,\n    stressLevel: profile.stressLevel ?? null,\n  }\n}\n\nfunction mapDbUserToUserAccount(row: any): UserAccount {\n  return {\n    email: row.email,\n    password_hash: row.password_hash,\n    name: row.name,\n    age: row.age,\n    gender: row.gender,\n    height: row.height ? parseFloat(row.height) : undefined,\n    weight: row.weight ? parseFloat(row.weight) : undefined,\n    goal: row.goal,\n    level: row.level,\n    location: row.location,\n    dietaryPrefs: row.dietary_prefs,\n    medicalHistory: row.medical_history,\n    stressLevel: row.stress_level,\n    created_at: row.created_at,\n    updated_at: row.updated_at,\n  }\n}\n\nexport async function fetchPlanByEmail(email: string): Promise<PlanRecord | null> {\n  await initPromise\n  // Fetch plan from user_plans and latest profile from user_accounts\n  const { rows } = await pool.query(\n    `select \n       p.email, \n       p.plan, \n       p.updated_at,\n       u.name, u.age, u.gender, u.height, u.weight, u.goal, u.level, u.location, \n       u.dietary_prefs, u.medical_history, u.stress_level\n     from ${TABLE} p\n     left join ${USER_TABLE} u on p.email = u.email\n     where p.email = $1 limit 1`,\n    [email],\n  )\n  \n  if (!rows[0]) return null\n\n  const row = rows[0]\n  // Construct user_data from the joined user_accounts table\n  const user_data: Partial<UserData> = {\n    name: row.name,\n    age: row.age,\n    gender: row.gender,\n    height: row.height ? parseFloat(row.height) : undefined,\n    weight: row.weight ? parseFloat(row.weight) : undefined,\n    goal: row.goal,\n    level: row.level,\n    location: row.location,\n    dietaryPrefs: row.dietary_prefs,\n    medicalHistory: row.medical_history,\n    stressLevel: row.stress_level,\n  }\n\n  return {\n    email: row.email,\n    user_data,\n    plan: row.plan,\n    updated_at: row.updated_at,\n  }\n}\n\nexport async function upsertPlanRecord(email: string, userData: Partial<UserData>, plan: PlanContent): Promise<PlanRecord> {\n  await initPromise\n  const { rows } = await pool.query(\n    `insert into ${TABLE} (email, user_data, plan, updated_at)\n     values ($1, $2::jsonb, $3::jsonb, now())\n     on conflict (email) do update set\n       user_data = EXCLUDED.user_data,\n       plan = EXCLUDED.plan,\n       updated_at = now()\n     returning email, user_data, plan, updated_at`,\n    [email, JSON.stringify(userData || {}), JSON.stringify(plan)],\n  )\n  return rows[0] as PlanRecord\n}\n\nexport async function fetchUserAccount(email: string): Promise<UserAccount | null> {\n  await initPromise\n  const { rows } = await pool.query(\n    `select * from ${USER_TABLE} where email = $1 limit 1`,\n    [email],\n  )\n  return rows[0] ? mapDbUserToUserAccount(rows[0]) : null\n}\n\nexport async function updateUserPassword(email: string, passwordHash: string): Promise<void> {\n  await initPromise\n  await pool.query(\n    `update ${USER_TABLE} set password_hash = $2, updated_at = now() where email = $1`,\n    [email, passwordHash]\n  )\n}\n\nexport async function upsertUserAccount(account: UserAccount): Promise<UserAccount> {\n  await initPromise\n  const { email, password_hash, ...profile } = account\n  const normalized = normalizeProfile(profile)\n\n  const { rows } = await pool.query(\n    `insert into ${USER_TABLE} (\n        email, password_hash, name, age, gender, height, weight, goal, level, location,\n        dietary_prefs, medical_history, stress_level, updated_at\n     ) values (\n        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11::text[], $12, $13, now()\n     )\n     on conflict (email) do update set\n        password_hash = EXCLUDED.password_hash,\n        name = EXCLUDED.name,\n        age = EXCLUDED.age,\n        gender = EXCLUDED.gender,\n        height = EXCLUDED.height,\n        weight = EXCLUDED.weight,\n        goal = EXCLUDED.goal,\n        level = EXCLUDED.level,\n        location = EXCLUDED.location,\n        dietary_prefs = EXCLUDED.dietary_prefs,\n        medical_history = EXCLUDED.medical_history,\n        stress_level = EXCLUDED.stress_level,\n        updated_at = now()\n     returning *`,\n    [\n      email,\n      password_hash,\n      normalized.name,\n      normalized.age,\n      normalized.gender,\n      normalized.height,\n      normalized.weight,\n      normalized.goal,\n      normalized.level,\n      normalized.location,\n      normalized.dietaryPrefs,\n      normalized.medicalHistory,\n      normalized.stressLevel,\n    ],\n  )\n\n  return mapDbUserToUserAccount(rows[0])\n}\n\nexport async function updateUserProfile(email: string, profile: Partial<UserData>): Promise<UserAccount | null> {\n  await initPromise\n  const normalized = normalizeProfile(profile)\n  const { rows } = await pool.query(\n    `update ${USER_TABLE}\n     set\n       name = coalesce($2, name),\n       age = coalesce($3::integer, age),\n       gender = coalesce($4, gender),\n       height = coalesce($5::numeric, height),\n       weight = coalesce($6::numeric, weight),\n       goal = coalesce($7, goal),\n       level = coalesce($8, level),\n       location = coalesce($9, location),\n       dietary_prefs = coalesce($10::text[], dietary_prefs),\n       medical_history = coalesce($11, medical_history),\n       stress_level = coalesce($12, stress_level),\n       updated_at = now()\n     where email = $1\n     returning *`,\n    [\n      email,\n      normalized.name,\n      normalized.age,\n      normalized.gender,\n      normalized.height,\n      normalized.weight,\n      normalized.goal,\n      normalized.level,\n      normalized.location,\n      normalized.dietaryPrefs,\n      normalized.medicalHistory,\n      normalized.stressLevel,\n    ],\n  )\n  return rows[0] ? mapDbUserToUserAccount(rows[0]) : null\n}"],"names":[],"mappings":"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"}},
    {"offset": {"line": 294, "column": 0}, "map": {"version":3,"sources":["file:///home/deepakps/Documents/GitHub/AI_fitness_coach/app/api/plan/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\"\nimport { fetchPlanByEmail, upsertPlanRecord, updateUserProfile } from \"@/backend/db\"\nimport type { PlanContent } from \"@/lib/plan-types\"\nimport type { UserData } from \"@/components/app-wrapper\"\n\nexport async function GET(req: Request) {\n  try {\n    const { searchParams } = new URL(req.url)\n    const email = searchParams.get(\"email\")\n    if (!email) {\n      return NextResponse.json({ error: \"Missing email\" }, { status: 400 })\n    }\n    const record = await fetchPlanByEmail(email)\n    return NextResponse.json({ record })\n  } catch (error) {\n    const message = (error as Error).message\n    return NextResponse.json({ error: message }, { status: 500 })\n  }\n}\n\nexport async function POST(req: Request) {\n  try {\n    const { email, userData, plan } = (await req.json()) as {\n      email: string\n      userData: Partial<UserData>\n      plan: PlanContent\n    }\n    if (!email || !plan) {\n      return NextResponse.json({ error: \"Missing email or plan\" }, { status: 400 })\n    }\n    const record = await upsertPlanRecord(email, userData, plan)\n    if (userData && Object.keys(userData).length > 0) {\n      await updateUserProfile(email, userData)\n    }\n    return NextResponse.json({ record })\n  } catch (error) {\n    const message = (error as Error).message\n    return NextResponse.json({ error: message }, { status: 500 })\n  }\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;;;;;;;AAIO,eAAe,IAAI,GAAY;IACpC,IAAI;QACF,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,IAAI,GAAG;QACxC,MAAM,QAAQ,aAAa,GAAG,CAAC;QAC/B,IAAI,CAAC,OAAO;YACV,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAgB,GAAG;gBAAE,QAAQ;YAAI;QACrE;QACA,MAAM,SAAS,MAAM,IAAA,mIAAgB,EAAC;QACtC,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE;QAAO;IACpC,EAAE,OAAO,OAAO;QACd,MAAM,UAAU,AAAC,MAAgB,OAAO;QACxC,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAQ,GAAG;YAAE,QAAQ;QAAI;IAC7D;AACF;AAEO,eAAe,KAAK,GAAY;IACrC,IAAI;QACF,MAAM,EAAE,KAAK,EAAE,QAAQ,EAAE,IAAI,EAAE,GAAI,MAAM,IAAI,IAAI;QAKjD,IAAI,CAAC,SAAS,CAAC,MAAM;YACnB,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAwB,GAAG;gBAAE,QAAQ;YAAI;QAC7E;QACA,MAAM,SAAS,MAAM,IAAA,mIAAgB,EAAC,OAAO,UAAU;QACvD,IAAI,YAAY,OAAO,IAAI,CAAC,UAAU,MAAM,GAAG,GAAG;YAChD,MAAM,IAAA,oIAAiB,EAAC,OAAO;QACjC;QACA,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE;QAAO;IACpC,EAAE,OAAO,OAAO;QACd,MAAM,UAAU,AAAC,MAAgB,OAAO;QACxC,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAQ,GAAG;YAAE,QAAQ;QAAI;IAC7D;AACF"}}]
}