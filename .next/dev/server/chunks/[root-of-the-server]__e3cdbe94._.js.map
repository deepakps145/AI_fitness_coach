{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 64, "column": 0}, "map": {"version":3,"sources":["file:///home/deepakps/Documents/GitHub/AI_fitness_coach/backend/db.ts"],"sourcesContent":["import { Pool } from \"pg\"\nimport type { PlanContent } from \"@/lib/plan-types\"\nimport type { UserData } from \"@/components/app-wrapper\"\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n  ssl: { rejectUnauthorized: false },\n})\n\nconst initPromise = pool.query(`\n  create table if not exists user_accounts (\n    email            text primary key,\n    password_hash    text not null,\n    name             text,\n    age              integer,\n    gender           text,\n    height           numeric(6,2),\n    weight           numeric(6,2),\n    goal             text,\n    level            text,\n    location         text,\n    dietary_prefs    text[],\n    medical_history  text,\n    stress_level     text,\n    created_at       timestamptz default now(),\n    updated_at       timestamptz default now()\n  );\n\n  create table if not exists user_plans (\n    email      text primary key references user_accounts(email) on delete cascade,\n    user_data  jsonb,\n    plan       jsonb not null,\n    updated_at timestamptz default now()\n  );\n`)\n\nconst TABLE = \"user_plans\"\nconst USER_TABLE = \"user_accounts\"\n\nexport interface PlanRecord {\n  email: string\n  user_data: Partial<UserData>\n  plan: PlanContent\n  updated_at?: string\n}\n\nexport interface UserAccount extends Partial<UserData> {\n  email: string\n  password_hash: string\n  created_at?: string\n  updated_at?: string\n}\n\nfunction normalizeProfile(profile: Partial<UserData>) {\n  return {\n    name: profile.name ?? null,\n    age: profile.age ?? null,\n    gender: profile.gender ?? null,\n    height: profile.height ?? null,\n    weight: profile.weight ?? null,\n    goal: profile.goal ?? null,\n    level: profile.level ?? null,\n    location: profile.location ?? null,\n    dietaryPrefs: profile.dietaryPrefs ?? null,\n    medicalHistory: profile.medicalHistory ?? null,\n    stressLevel: profile.stressLevel ?? null,\n  }\n}\n\nexport async function fetchPlanByEmail(email: string): Promise<PlanRecord | null> {\n  await initPromise\n  const { rows } = await pool.query(\n    `select email, user_data, plan, updated_at from ${TABLE} where email = $1 limit 1`,\n    [email],\n  )\n  return (rows[0] as PlanRecord | undefined) || null\n}\n\nexport async function upsertPlanRecord(email: string, userData: Partial<UserData>, plan: PlanContent): Promise<PlanRecord> {\n  await initPromise\n  const { rows } = await pool.query(\n    `insert into ${TABLE} (email, user_data, plan, updated_at)\n     values ($1, $2::jsonb, $3::jsonb, now())\n     on conflict (email) do update set\n       user_data = EXCLUDED.user_data,\n       plan = EXCLUDED.plan,\n       updated_at = now()\n     returning email, user_data, plan, updated_at`,\n    [email, JSON.stringify(userData || {}), JSON.stringify(plan)],\n  )\n  return rows[0] as PlanRecord\n}\n\nexport async function fetchUserAccount(email: string): Promise<UserAccount | null> {\n  await initPromise\n  const { rows } = await pool.query(\n    `select * from ${USER_TABLE} where email = $1 limit 1`,\n    [email],\n  )\n  return (rows[0] as UserAccount | undefined) || null\n}\n\nexport async function upsertUserAccount(account: UserAccount): Promise<UserAccount> {\n  await initPromise\n  const { email, password_hash, ...profile } = account\n  const normalized = normalizeProfile(profile)\n\n  const { rows } = await pool.query(\n    `insert into ${USER_TABLE} (\n        email, password_hash, name, age, gender, height, weight, goal, level, location,\n        dietary_prefs, medical_history, stress_level, updated_at\n     ) values (\n        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11::text[], $12, $13, now()\n     )\n     on conflict (email) do update set\n        password_hash = EXCLUDED.password_hash,\n        name = EXCLUDED.name,\n        age = EXCLUDED.age,\n        gender = EXCLUDED.gender,\n        height = EXCLUDED.height,\n        weight = EXCLUDED.weight,\n        goal = EXCLUDED.goal,\n        level = EXCLUDED.level,\n        location = EXCLUDED.location,\n        dietary_prefs = EXCLUDED.dietary_prefs,\n        medical_history = EXCLUDED.medical_history,\n        stress_level = EXCLUDED.stress_level,\n        updated_at = now()\n     returning *`,\n    [\n      email,\n      password_hash,\n      normalized.name,\n      normalized.age,\n      normalized.gender,\n      normalized.height,\n      normalized.weight,\n      normalized.goal,\n      normalized.level,\n      normalized.location,\n      normalized.dietaryPrefs,\n      normalized.medicalHistory,\n      normalized.stressLevel,\n    ],\n  )\n\n  return rows[0] as UserAccount\n}\n\nexport async function updateUserProfile(email: string, profile: Partial<UserData>): Promise<UserAccount | null> {\n  await initPromise\n  const normalized = normalizeProfile(profile)\n  const { rows } = await pool.query(\n    `update ${USER_TABLE}\n     set\n       name = coalesce($2, name),\n       age = coalesce($3::integer, age),\n       gender = coalesce($4, gender),\n       height = coalesce($5::numeric, height),\n       weight = coalesce($6::numeric, weight),\n       goal = coalesce($7, goal),\n       level = coalesce($8, level),\n       location = coalesce($9, location),\n       dietary_prefs = coalesce($10::text[], dietary_prefs),\n       medical_history = coalesce($11, medical_history),\n       stress_level = coalesce($12, stress_level),\n       updated_at = now()\n     where email = $1\n     returning *`,\n    [\n      email,\n      normalized.name,\n      normalized.age,\n      normalized.gender,\n      normalized.height,\n      normalized.weight,\n      normalized.goal,\n      normalized.level,\n      normalized.location,\n      normalized.dietaryPrefs,\n      normalized.medicalHistory,\n      normalized.stressLevel,\n    ],\n  )\n  return (rows[0] as UserAccount | undefined) || null\n}\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;;;;;;AAIA,MAAM,OAAO,IAAI,4GAAI,CAAC;IACpB,kBAAkB,QAAQ,GAAG,CAAC,YAAY;IAC1C,KAAK;QAAE,oBAAoB;IAAM;AACnC;AAEA,MAAM,cAAc,KAAK,KAAK,CAAC,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;AAyBhC,CAAC;AAED,MAAM,QAAQ;AACd,MAAM,aAAa;AAgBnB,SAAS,iBAAiB,OAA0B;IAClD,OAAO;QACL,MAAM,QAAQ,IAAI,IAAI;QACtB,KAAK,QAAQ,GAAG,IAAI;QACpB,QAAQ,QAAQ,MAAM,IAAI;QAC1B,QAAQ,QAAQ,MAAM,IAAI;QAC1B,QAAQ,QAAQ,MAAM,IAAI;QAC1B,MAAM,QAAQ,IAAI,IAAI;QACtB,OAAO,QAAQ,KAAK,IAAI;QACxB,UAAU,QAAQ,QAAQ,IAAI;QAC9B,cAAc,QAAQ,YAAY,IAAI;QACtC,gBAAgB,QAAQ,cAAc,IAAI;QAC1C,aAAa,QAAQ,WAAW,IAAI;IACtC;AACF;AAEO,eAAe,iBAAiB,KAAa;IAClD,MAAM;IACN,MAAM,EAAE,IAAI,EAAE,GAAG,MAAM,KAAK,KAAK,CAC/B,CAAC,+CAA+C,EAAE,MAAM,yBAAyB,CAAC,EAClF;QAAC;KAAM;IAET,OAAO,AAAC,IAAI,CAAC,EAAE,IAA+B;AAChD;AAEO,eAAe,iBAAiB,KAAa,EAAE,QAA2B,EAAE,IAAiB;IAClG,MAAM;IACN,MAAM,EAAE,IAAI,EAAE,GAAG,MAAM,KAAK,KAAK,CAC/B,CAAC,YAAY,EAAE,MAAM;;;;;;iDAMwB,CAAC,EAC9C;QAAC;QAAO,KAAK,SAAS,CAAC,YAAY,CAAC;QAAI,KAAK,SAAS,CAAC;KAAM;IAE/D,OAAO,IAAI,CAAC,EAAE;AAChB;AAEO,eAAe,iBAAiB,KAAa;IAClD,MAAM;IACN,MAAM,EAAE,IAAI,EAAE,GAAG,MAAM,KAAK,KAAK,CAC/B,CAAC,cAAc,EAAE,WAAW,yBAAyB,CAAC,EACtD;QAAC;KAAM;IAET,OAAO,AAAC,IAAI,CAAC,EAAE,IAAgC;AACjD;AAEO,eAAe,kBAAkB,OAAoB;IAC1D,MAAM;IACN,MAAM,EAAE,KAAK,EAAE,aAAa,EAAE,GAAG,SAAS,GAAG;IAC7C,MAAM,aAAa,iBAAiB;IAEpC,MAAM,EAAE,IAAI,EAAE,GAAG,MAAM,KAAK,KAAK,CAC/B,CAAC,YAAY,EAAE,WAAW;;;;;;;;;;;;;;;;;;;;gBAoBd,CAAC,EACb;QACE;QACA;QACA,WAAW,IAAI;QACf,WAAW,GAAG;QACd,WAAW,MAAM;QACjB,WAAW,MAAM;QACjB,WAAW,MAAM;QACjB,WAAW,IAAI;QACf,WAAW,KAAK;QAChB,WAAW,QAAQ;QACnB,WAAW,YAAY;QACvB,WAAW,cAAc;QACzB,WAAW,WAAW;KACvB;IAGH,OAAO,IAAI,CAAC,EAAE;AAChB;AAEO,eAAe,kBAAkB,KAAa,EAAE,OAA0B;IAC/E,MAAM;IACN,MAAM,aAAa,iBAAiB;IACpC,MAAM,EAAE,IAAI,EAAE,GAAG,MAAM,KAAK,KAAK,CAC/B,CAAC,OAAO,EAAE,WAAW;;;;;;;;;;;;;;;gBAeT,CAAC,EACb;QACE;QACA,WAAW,IAAI;QACf,WAAW,GAAG;QACd,WAAW,MAAM;QACjB,WAAW,MAAM;QACjB,WAAW,MAAM;QACjB,WAAW,IAAI;QACf,WAAW,KAAK;QAChB,WAAW,QAAQ;QACnB,WAAW,YAAY;QACvB,WAAW,cAAc;QACzB,WAAW,WAAW;KACvB;IAEH,OAAO,AAAC,IAAI,CAAC,EAAE,IAAgC;AACjD"}},
    {"offset": {"line": 242, "column": 0}, "map": {"version":3,"sources":["file:///home/deepakps/Documents/GitHub/AI_fitness_coach/app/api/user/route.ts"],"sourcesContent":["import { createHash } from \"crypto\"\nimport { NextResponse } from \"next/server\"\nimport type { UserData } from \"@/components/app-wrapper\"\nimport { fetchUserAccount, upsertUserAccount } from \"@/backend/db\"\n\nfunction hashPassword(password: string) {\n  return createHash(\"sha256\").update(password).digest(\"hex\")\n}\n\nexport async function POST(req: Request) {\n  try {\n    const { mode, email, password, profile } = (await req.json()) as {\n      mode: \"signup\" | \"login\"\n      email: string\n      password: string\n      profile?: Partial<UserData>\n    }\n\n    if (!mode || !email || !password) {\n      return NextResponse.json({ error: \"Missing email, password, or mode\" }, { status: 400 })\n    }\n\n    const passwordHash = hashPassword(password)\n\n    if (mode === \"signup\") {\n      const existing = await fetchUserAccount(email)\n      if (existing) {\n        return NextResponse.json({ error: \"Email already exists\" }, { status: 409 })\n      }\n      const record = await upsertUserAccount({ email, password_hash: passwordHash, ...profile })\n      return NextResponse.json({ user: record })\n    }\n\n    const record = await fetchUserAccount(email)\n    if (!record) {\n      return NextResponse.json({ error: \"Account not found\" }, { status: 404 })\n    }\n\n    if (record.password_hash !== passwordHash) {\n      return NextResponse.json({ error: \"Invalid credentials\" }, { status: 401 })\n    }\n\n    return NextResponse.json({ user: record })\n  } catch (error) {\n    const message = (error as Error).message\n    return NextResponse.json({ error: message }, { status: 500 })\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AAEA;;;;;;;;AAEA,SAAS,aAAa,QAAgB;IACpC,OAAO,IAAA,mHAAU,EAAC,UAAU,MAAM,CAAC,UAAU,MAAM,CAAC;AACtD;AAEO,eAAe,KAAK,GAAY;IACrC,IAAI;QACF,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,QAAQ,EAAE,OAAO,EAAE,GAAI,MAAM,IAAI,IAAI;QAO1D,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,UAAU;YAChC,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAmC,GAAG;gBAAE,QAAQ;YAAI;QACxF;QAEA,MAAM,eAAe,aAAa;QAElC,IAAI,SAAS,UAAU;YACrB,MAAM,WAAW,MAAM,IAAA,mIAAgB,EAAC;YACxC,IAAI,UAAU;gBACZ,OAAO,gJAAY,CAAC,IAAI,CAAC;oBAAE,OAAO;gBAAuB,GAAG;oBAAE,QAAQ;gBAAI;YAC5E;YACA,MAAM,SAAS,MAAM,IAAA,oIAAiB,EAAC;gBAAE;gBAAO,eAAe;gBAAc,GAAG,OAAO;YAAC;YACxF,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,MAAM;YAAO;QAC1C;QAEA,MAAM,SAAS,MAAM,IAAA,mIAAgB,EAAC;QACtC,IAAI,CAAC,QAAQ;YACX,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAoB,GAAG;gBAAE,QAAQ;YAAI;QACzE;QAEA,IAAI,OAAO,aAAa,KAAK,cAAc;YACzC,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAsB,GAAG;gBAAE,QAAQ;YAAI;QAC3E;QAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,MAAM;QAAO;IAC1C,EAAE,OAAO,OAAO;QACd,MAAM,UAAU,AAAC,MAAgB,OAAO;QACxC,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAQ,GAAG;YAAE,QAAQ;QAAI;IAC7D;AACF"}}]
}