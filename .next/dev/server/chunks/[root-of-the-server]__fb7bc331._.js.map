{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///home/deepakps/Documents/GitHub/AI_fitness_coach/backend/gemini.ts"],"sourcesContent":["import { Buffer } from \"buffer\"\nimport type { PlanContent } from \"@/lib/plan-types\"\n\nconst GEMINI_MODEL = process.env.GEMINI_MODEL?.trim() || \"gemini-2.5-flash\"\nconst GEMINI_BASE = \"https://generativelanguage.googleapis.com/v1beta\"\n\nconst DEFAULT_MOTIVATION = \"Your plan is ready. Stay consistent and you'll see results.\"\n\nfunction buildPrompt(body: Record<string, unknown>) {\n  const lines = [\n    \"You are an expert fitness coach and dietitian.\",\n    \"Respond ONLY with valid JSON. Do not include code fences, markdown, or prose.\",\n    \"Ensure all keys and string values are enclosed in double quotes.\",\n    \"Do not use trailing commas.\",\n    \"Fields: workouts (array of {name, sets, reps, rest, focus, imagePrompt}), meals (array of {meal, items, calories, protein, carbs, fats, imagePrompt}), tips (array of strings), motivation (single string).\",\n    \"Keep workouts 4-6 items, meals 4 items (breakfast, lunch, snack, dinner).\",\n    \"Tailor to the user's goals, level, location, dietary preferences, and medical notes.\",\n    `User data: ${JSON.stringify(body)}`,\n  ]\n  return lines.join(\"\\n\")\n}\n\nfunction buildTipsPrompt(body: Record<string, unknown>, plan?: Pick<PlanContent, \"workouts\" | \"meals\">) {\n  const lines = [\n    \"You are a motivational fitness coach.\",\n    \"Respond ONLY with JSON containing { \\\"tips\\\": string[], \\\"motivation\\\": string }.\",\n    \"Tips must be actionable (max 2 sentences each). Motivation should be a single uplifting quote.\",\n    `User data: ${JSON.stringify(body)}`,\n  ]\n  if (plan) {\n    lines.push(`Current plan context: ${JSON.stringify(plan)}`)\n  }\n  return lines.join(\"\\n\")\n}\n\nconst extractJson = (text: string): string | null => {\n  const fenced = text.match(/```json([\\s\\S]*?)```/i)\n  if (fenced?.[1]) return fenced[1].trim()\n  const braces = text.match(/\\{[\\s\\S]*\\}/)\n  if (braces?.[0]) return braces[0].trim()\n  return null\n}\n\nconst repairJson = (text: string): string => {\n  // 1. Remove markdown code blocks\n  let cleaned = text.replace(/```json/gi, \"\").replace(/```/g, \"\").trim()\n  \n  // 2. Attempt to fix common JSON syntax errors\n  // Replace single quotes with double quotes for keys/values, but be careful about apostrophes in text\n  // This is hard to do perfectly with regex. \n  // Instead, let's focus on the structure.\n  \n  // If the model returns \"key\": \"value\" \"key2\": \"value\" (missing comma)\n  // We can try to insert commas between value and key.\n  // Look for \" (end of string) followed by whitespace/newlines then \" (start of key)\n  cleaned = cleaned.replace(/\"\\s+(?=\")/g, '\", ')\n  \n  // If the model returns number followed by key without comma: 123 \"key\"\n  cleaned = cleaned.replace(/(\\d+)\\s+(?=\")/g, '$1, ')\n\n  // If the model returns boolean followed by key without comma: true \"key\"\n  cleaned = cleaned.replace(/(true|false)\\s+(?=\")/g, '$1, ')\n\n  // Remove trailing commas before closing braces/brackets\n  cleaned = cleaned.replace(/,\\s*([\\]}])/g, '$1')\n\n  return cleaned\n}\n\nasync function requestGemini(prompt: string, retries = 3, delay = 1000) {\n  if (!process.env.GEMINI_API_KEY) {\n    throw new Error(\"GEMINI_API_KEY is not set\")\n  }\n\n  for (let i = 0; i < retries; i++) {\n    try {\n      const geminiRes = await fetch(\n        `${GEMINI_BASE}/models/${encodeURIComponent(GEMINI_MODEL)}:generateContent?key=${process.env.GEMINI_API_KEY}`,\n        {\n          method: \"POST\",\n          headers: { \"Content-Type\": \"application/json\" },\n          body: JSON.stringify({\n            contents: [\n              {\n                role: \"user\",\n                parts: [{ text: prompt }],\n              },\n            ],\n            generationConfig: {\n              temperature: 0.8,\n              maxOutputTokens: 8192,\n              responseMimeType: \"application/json\",\n            },\n          }),\n        },\n      )\n\n      if (!geminiRes.ok) {\n        const errorText = await geminiRes.text()\n        let errorJson: any\n        try {\n          errorJson = JSON.parse(errorText)\n        } catch {\n          // If not JSON, use text\n        }\n\n        const status = geminiRes.status\n        const message = errorJson?.error?.message || errorText\n\n        // Handle 503 (Overloaded) and 429 (Rate Limit) with retries\n        if (status === 503 || status === 429) {\n          if (i < retries - 1) {\n            // Exponential backoff: 1s, 2s, 4s...\n            const waitTime = delay * Math.pow(2, i)\n            console.warn(`Gemini API ${status} error. Retrying in ${waitTime}ms...`)\n            await new Promise((resolve) => setTimeout(resolve, waitTime))\n            continue\n          }\n        }\n\n        // If we are here, it's a fatal error or we ran out of retries\n        if (status === 429) {\n           throw new Error(\"AI Usage Limit Exceeded. Please try again later.\")\n        }\n        if (status === 503) {\n           throw new Error(\"AI Service Overloaded. Please try again in a moment.\")\n        }\n\n        throw new Error(message || `Gemini request failed with status ${status}`)\n      }\n\n      const geminiJson = (await geminiRes.json()) as any\n      const parts = geminiJson?.candidates?.[0]?.content?.parts\n      const rawText: string | undefined = Array.isArray(parts)\n        ? parts\n            .map((p: any) => {\n              if (typeof p?.text === \"string\") return p.text\n              if (p?.inlineData?.data) {\n                try {\n                  const buf = Buffer.from(p.inlineData.data, \"base64\").toString(\"utf8\")\n                  return buf\n                } catch {\n                  return \"\"\n                }\n              }\n              if (p?.json) {\n                try {\n                  return JSON.stringify(p.json)\n                } catch {\n                  return \"\"\n                }\n              }\n              return \"\"\n            })\n            .join(\"\\n\")\n            .trim()\n        : undefined\n      if (!rawText) {\n        throw new Error(\"No content returned from Gemini\")\n      }\n\n      return rawText\n\n    } catch (error) {\n      // If it's the last retry, rethrow\n      if (i === retries - 1) throw error\n      // If it's a network error (fetch failed), wait and retry\n      const waitTime = delay * Math.pow(2, i)\n      console.warn(`Network error. Retrying in ${waitTime}ms...`, error)\n      await new Promise((resolve) => setTimeout(resolve, waitTime))\n    }\n  }\n  throw new Error(\"Failed to connect to AI service after multiple attempts\")\n}\n\nfunction parseJsonPayload<T>(rawText: string): T {\n  try {\n    const cleaned = extractJson(rawText) ?? rawText.trim()\n    return JSON.parse(cleaned) as T\n  } catch (err) {\n    const repaired = repairJson(rawText)\n    return JSON.parse(repaired) as T\n  }\n}\n\nexport async function generatePlanFromGemini(body: Record<string, unknown>): Promise<PlanContent> {\n  const prompt = buildPrompt(body)\n  const rawText = await requestGemini(prompt)\n  const parsed = parseJsonPayload<PlanContent>(rawText)\n\n  return {\n    workouts: parsed.workouts || [],\n    meals: parsed.meals || [],\n    tips: parsed.tips || [],\n    motivation: parsed.motivation || DEFAULT_MOTIVATION,\n  }\n}\n\nexport async function generateTipsFromGemini(\n  body: Record<string, unknown>,\n  plan?: Pick<PlanContent, \"workouts\" | \"meals\">,\n): Promise<{ tips: string[]; motivation: string }> {\n  const prompt = buildTipsPrompt(body, plan)\n  const rawText = await requestGemini(prompt)\n  const parsed = parseJsonPayload<{ tips?: string[]; motivation?: string }>(rawText)\n  return {\n    tips: parsed.tips || [],\n    motivation: parsed.motivation || DEFAULT_MOTIVATION,\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 241, "column": 0}, "map": {"version":3,"sources":["file:///home/deepakps/Documents/GitHub/AI_fitness_coach/app/api/generate-tips/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\"\nimport { generateTipsFromGemini } from \"@/backend/gemini\"\nimport type { PlanContent } from \"@/lib/plan-types\"\nimport type { UserData } from \"@/components/app-wrapper\"\n\nexport async function POST(req: Request) {\n  try {\n    const { userData, plan } = (await req.json()) as {\n      userData: Partial<UserData>\n      plan?: Pick<PlanContent, \"workouts\" | \"meals\">\n    }\n    if (!userData) {\n      return NextResponse.json({ error: \"Missing user data\" }, { status: 400 })\n    }\n    const tips = await generateTipsFromGemini(userData, plan)\n    return NextResponse.json(tips)\n  } catch (error) {\n    const message = (error as Error).message\n    return NextResponse.json({ error: message }, { status: 500 })\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAIO,eAAe,KAAK,GAAY;IACrC,IAAI;QACF,MAAM,EAAE,QAAQ,EAAE,IAAI,EAAE,GAAI,MAAM,IAAI,IAAI;QAI1C,IAAI,CAAC,UAAU;YACb,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAoB,GAAG;gBAAE,QAAQ;YAAI;QACzE;QACA,MAAM,OAAO,MAAM,IAAA,6IAAsB,EAAC,UAAU;QACpD,OAAO,gJAAY,CAAC,IAAI,CAAC;IAC3B,EAAE,OAAO,OAAO;QACd,MAAM,UAAU,AAAC,MAAgB,OAAO;QACxC,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAQ,GAAG;YAAE,QAAQ;QAAI;IAC7D;AACF"}}]
}